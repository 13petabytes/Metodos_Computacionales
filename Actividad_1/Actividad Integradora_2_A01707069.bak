#lang racket

display("Incerte el cuerpo del automata a trabajar:")
(newline)

(define (validate automaton strings)
  (define states (first automaton))
  (define alphabet (second automaton))
  (define transitions (third automaton))
  (define start (fourth automaton))
  (define finals (fifth automaton))

  ;; Tabla de transiciones como una lista de pares: '(((estado simbolo) . estado-final) ...)
  (define transition-table
    (map (lambda (t)
           (cons (list (first t) (second t)) (third t)))
         transitions))

  ;; Función para encontrar el siguiente estado
  (define next-state
    (lambda (state symbol)
      (let ((pair (assoc (list state symbol) transition-table)))
        (if pair (cdr pair) #f))))

  ;; Función que verifica si una cadena es aceptada
  (define accepts?
    (lambda (input)
      (letrec ((walk
                (lambda (state symbols)
                  (if (null? symbols)
                      (member state finals)
                      (let ((next (next-state state (car symbols))))
                        (if next
                            (walk next (cdr symbols))
                            #f))))))
        (walk start input))))

  ;; Aplicar la función accepts? a cada cadena
  (map (lambda (s) (accepts? s)) strings))

